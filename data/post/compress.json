{"author":"김준혁","title":"compress","description":"Note\r\nThis page was generated from the compression README.\r\ncompression\r\nNPM Version NPM Downloads Build Status OpenSSF Scorecard Badge Funding\r\n\r\nNode.js compression middleware.\r\n\r\nThe following compression codings are supported:\r\n\r\ndeflate\r\ngzip\r\nbr (brotli)\r\nNote Brotli is supported only since Node.js versions v11.7.0 and v10.16.0.\r\n\r\nInstall\r\nThis is a Node.js module available through the npm registry. Installation is done using the npm install command:\r\n\r\n$ npm install compression\r\nAPI\r\nvar compression = require('compression')\r\ncompression([options])\r\nReturns the compression middleware using the given options. The middleware will attempt to compress response bodies for all requests that traverse through the middleware, based on the given options.\r\n\r\nThis middleware will never compress responses that include a Cache-Control header with the no-transform directive, as compressing will transform the body.\r\n\r\nOptions\r\ncompression() accepts these properties in the options object. In addition to those listed below, zlib options may be passed in to the options object or brotli options.\r\n\r\nchunkSize\r\nType: Number\r\nDefault: zlib.constants.Z_DEFAULT_CHUNK, or 16384.\r\n\r\nSee Node.js documentation regarding the usage.\r\n\r\nfilter\r\nType: Function\r\n\r\nA function to decide if the response should be considered for compression. This function is called as filter(req, res) and is expected to return true to consider the response for compression, or false to not compress the response.\r\n\r\nThe default filter function uses the compressible module to determine if res.getHeader('Content-Type') is compressible.\r\n\r\nlevel\r\nType: Number\r\nDefault: zlib.constants.Z_DEFAULT_COMPRESSION, or -1\r\n\r\nThe level of zlib compression to apply to responses. A higher level will result in better compression, but will take longer to complete. A lower level will result in less compression, but will be much faster.\r\n\r\nThis is an integer in the range of 0 (no compression) to 9 (maximum compression). The special value -1 can be used to mean the “default compression level”, which is a default compromise between speed and compression (currently equivalent to level 6).\r\n\r\n-1 Default compression level (also zlib.constants.Z_DEFAULT_COMPRESSION).\r\n0 No compression (also zlib.constants.Z_NO_COMPRESSION).\r\n1 Fastest compression (also zlib.constants.Z_BEST_SPEED).\r\n2\r\n3\r\n4\r\n5\r\n6 (currently what zlib.constants.Z_DEFAULT_COMPRESSION points to).\r\n7\r\n8\r\n9 Best compression (also zlib.constants.Z_BEST_COMPRESSION).\r\nNote in the list above, zlib is from zlib = require('zlib').\r\n\r\nmemLevel\r\nType: Number\r\nDefault: zlib.constants.Z_DEFAULT_MEMLEVEL, or 8\r\n\r\nThis specifies how much memory should be allocated for the internal compression state and is an integer in the range of 1 (minimum level) and 9 (maximum level).\r\n\r\nSee Node.js documentation regarding the usage.\r\n\r\nbrotli\r\nType: Object\r\n\r\nThis specifies the options for configuring Brotli. See Node.js documentation for a complete list of available options.\r\n\r\nstrategy\r\nType: Number\r\nDefault: zlib.constants.Z_DEFAULT_STRATEGY\r\n\r\nThis is used to tune the compression algorithm. This value only affects the compression ratio, not the correctness of the compressed output, even if it is not set appropriately.\r\n\r\nzlib.constants.Z_DEFAULT_STRATEGY Use for normal data.\r\nzlib.constants.Z_FILTERED Use for data produced by a filter (or predictor). Filtered data consists mostly of small values with a somewhat random distribution. In this case, the compression algorithm is tuned to compress them better. The effect is to force more Huffman coding and less string matching; it is somewhat intermediate between zlib.constants.Z_DEFAULT_STRATEGY and zlib.constants.Z_HUFFMAN_ONLY.\r\nzlib.constants.Z_FIXED Use to prevent the use of dynamic Huffman codes, allowing for a simpler decoder for special applications.\r\nzlib.constants.Z_HUFFMAN_ONLY Use to force Huffman encoding only (no string match).\r\nzlib.constants.Z_RLE Use to limit match distances to one (run-length encoding). This is designed to be almost as fast as zlib.constants.Z_HUFFMAN_ONLY, but give better compression for PNG image data.\r\nNote in the list above, zlib is from zlib = require('zlib').\r\n\r\nthreshold\r\nType: Number or String\r\nDefault: 1kb\r\n\r\nThe byte threshold for the response body size before compression is considered for the response. This is a number of bytes or any string accepted by the bytes module.\r\n\r\nNote this is only an advisory setting; if the response size cannot be determined at the time the response headers are written, then it is assumed the response is over the threshold. To guarantee the response size can be determined, be sure set a Content-Length response header.\r\n\r\nwindowBits\r\nType: Number\r\nDefault: zlib.constants.Z_DEFAULT_WINDOWBITS, or 15\r\n\r\nSee Node.js documentation regarding the usage.\r\n\r\nenforceEncoding\r\nType: String\r\nDefault: identity\r\n\r\nThis is the default encoding to use when the client does not specify an encoding in the request’s Accept-Encoding header.\r\n\r\n.filter\r\nThe default filter function. This is used to construct a custom filter function that is an extension of the default function.\r\n\r\nvar compression = require('compression')\r\nvar express = require('express')\r\n\r\nvar app = express()\r\n\r\napp.use(compression({ filter: shouldCompress }))\r\n\r\nfunction shouldCompress (req, res) {\r\n  if (req.headers['x-no-compression']) {\r\n    // don't compress responses with this request header\r\n    return false\r\n  }\r\n\r\n  // fallback to standard filter function\r\n  return compression.filter(req, res)\r\n}\r\nres.flush\r\nThis module adds a res.flush() method to force the partially-compressed response to be flushed to the client.\r\n\r\nExamples\r\nexpress\r\nWhen using this module with express, simply app.use the module as high as you like. Requests that pass through the middleware will be compressed.\r\n\r\nvar compression = require('compression')\r\nvar express = require('express')\r\n\r\nvar app = express()\r\n\r\n// compress all responses\r\napp.use(compression())\r\n\r\n// add all routes\r\nNode.js HTTP server\r\nvar compression = require('compression')({ threshold: 0 })\r\nvar http = require('http')\r\n\r\nfunction createServer (fn) {\r\n  return http.createServer(function (req, res) {\r\n    compression(req, res, function (err) {\r\n      if (err) {\r\n        res.statusCode = err.status || 500\r\n        res.end(err.message)\r\n        return\r\n      }\r\n\r\n      fn(req, res)\r\n    })\r\n  })\r\n}\r\n\r\nvar server = createServer(function (req, res) {\r\n  res.setHeader('Content-Type', 'text/plain')\r\n  res.end('hello world!')\r\n})\r\n\r\nserver.listen(3000, () => {\r\n  console.log('> Listening at http://localhost:3000')\r\n})\r\nServer-Sent Events\r\nBecause of the nature of compression this module does not work out of the box with server-sent events. To compress content, a window of the output needs to be buffered up in order to get good compression. Typically when using server-sent events, there are certain block of data that need to reach the client.\r\n\r\nYou can achieve this by calling res.flush() when you need the data written to actually make it to the client.\r\n\r\nvar compression = require('compression')\r\nvar express = require('express')\r\n\r\nvar app = express()\r\n\r\n// compress responses\r\napp.use(compression())\r\n\r\n// server-sent event stream\r\napp.get('/events', function (req, res) {\r\n  res.setHeader('Content-Type', 'text/event-stream')\r\n  res.setHeader('Cache-Control', 'no-cache')\r\n\r\n  // send a ping approx every 2 seconds\r\n  var timer = setInterval(function () {\r\n    res.write('data: ping\\n\\n')\r\n\r\n    // !!! this is the important part\r\n    res.flush()\r\n  }, 2000)\r\n\r\n  res.on('close', function () {\r\n    clearInterval(timer)\r\n  })\r\n})\r\nContributing\r\nThe Express.js project welcomes all constructive contributions. Contributions take many forms, from code for bug fixes and enhancements, to additions and fixes to documentation, additional tests, triaging incoming pull requests and issues, and more!\r\n\r\nSee the Contributing Guide for more technical details on contributing.\r\n\r\nLicense\r\nMITNote\r\n\r\nThis page was generated from the compression README.\r\ncompression\r\nNPM Version NPM Downloads Build Status OpenSSF Scorecard Badge Funding\r\n\r\nNode.js compression middleware.\r\n\r\nThe following compression codings are supported:\r\n\r\ndeflate\r\ngzip\r\nbr (brotli)\r\nNote Brotli is supported only since Node.js versions v11.7.0 and v10.16.0.\r\n\r\nInstall\r\nThis is a Node.js module available through the npm registry. Installation is done using the npm install command:\r\n\r\n$ npm install compression\r\nAPI\r\nvar compression = require('compression')\r\ncompression([options])\r\nReturns the compression middleware using the given options. The middleware will attempt to compress response bodies for all requests that traverse through the middleware, based on the given options.\r\n\r\nThis middleware will never compress responses that include a Cache-Control header with the no-transform directive, as compressing will transform the body.\r\n\r\nOptions\r\ncompression() accepts these properties in the options object. In addition to those listed below, zlib options may be passed in to the options object or brotli options.\r\n\r\nchunkSize\r\nType: Number\r\nDefault: zlib.constants.Z_DEFAULT_CHUNK, or 16384.\r\n\r\nSee Node.js documentation regarding the usage.\r\n\r\nfilter\r\nType: Function\r\n\r\nA function to decide if the response should be considered for compression. This function is called as filter(req, res) and is expected to return true to consider the response for compression, or false to not compress the response.\r\n\r\nThe default filter function uses the compressible module to determine if res.getHeader('Content-Type') is compressible.\r\n\r\nlevel\r\nType: Number\r\nDefault: zlib.constants.Z_DEFAULT_COMPRESSION, or -1\r\n\r\nThe level of zlib compression to apply to responses. A higher level will result in better compression, but will take longer to complete. A lower level will result in less compression, but will be much faster.\r\n\r\nThis is an integer in the range of 0 (no compression) to 9 (maximum compression). The special value -1 can be used to mean the “default compression level”, which is a default compromise between speed and compression (currently equivalent to level 6).\r\n\r\n-1 Default compression level (also zlib.constants.Z_DEFAULT_COMPRESSION).\r\n0 No compression (also zlib.constants.Z_NO_COMPRESSION).\r\n1 Fastest compression (also zlib.constants.Z_BEST_SPEED).\r\n2\r\n3\r\n4\r\n5\r\n6 (currently what zlib.constants.Z_DEFAULT_COMPRESSION points to).\r\n7\r\n8\r\n9 Best compression (also zlib.constants.Z_BEST_COMPRESSION).\r\nNote in the list above, zlib is from zlib = require('zlib').\r\n\r\nmemLevel\r\nType: Number\r\nDefault: zlib.constants.Z_DEFAULT_MEMLEVEL, or 8\r\n\r\nThis specifies how much memory should be allocated for the internal compression state and is an integer in the range of 1 (minimum level) and 9 (maximum level).\r\n\r\nSee Node.js documentation regarding the usage.\r\n\r\nbrotli\r\nType: Object\r\n\r\nThis specifies the options for configuring Brotli. See Node.js documentation for a complete list of available options.\r\n\r\nstrategy\r\nType: Number\r\nDefault: zlib.constants.Z_DEFAULT_STRATEGY\r\n\r\nThis is used to tune the compression algorithm. This value only affects the compression ratio, not the correctness of the compressed output, even if it is not set appropriately.\r\n\r\nzlib.constants.Z_DEFAULT_STRATEGY Use for normal data.\r\nzlib.constants.Z_FILTERED Use for data produced by a filter (or predictor). Filtered data consists mostly of small values with a somewhat random distribution. In this case, the compression algorithm is tuned to compress them better. The effect is to force more Huffman coding and less string matching; it is somewhat intermediate between zlib.constants.Z_DEFAULT_STRATEGY and zlib.constants.Z_HUFFMAN_ONLY.\r\nzlib.constants.Z_FIXED Use to prevent the use of dynamic Huffman codes, allowing for a simpler decoder for special applications.\r\nzlib.constants.Z_HUFFMAN_ONLY Use to force Huffman encoding only (no string match).\r\nzlib.constants.Z_RLE Use to limit match distances to one (run-length encoding). This is designed to be almost as fast as zlib.constants.Z_HUFFMAN_ONLY, but give better compression for PNG image data.\r\nNote in the list above, zlib is from zlib = require('zlib').\r\n\r\nthreshold\r\nType: Number or String\r\nDefault: 1kb\r\n\r\nThe byte threshold for the response body size before compression is considered for the response. This is a number of bytes or any string accepted by the bytes module.\r\n\r\nNote this is only an advisory setting; if the response size cannot be determined at the time the response headers are written, then it is assumed the response is over the threshold. To guarantee the response size can be determined, be sure set a Content-Length response header.\r\n\r\nwindowBits\r\nType: Number\r\nDefault: zlib.constants.Z_DEFAULT_WINDOWBITS, or 15\r\n\r\nSee Node.js documentation regarding the usage.\r\n\r\nenforceEncoding\r\nType: String\r\nDefault: identity\r\n\r\nThis is the default encoding to use when the client does not specify an encoding in the request’s Accept-Encoding header.\r\n\r\n.filter\r\nThe default filter function. This is used to construct a custom filter function that is an extension of the default function.\r\n\r\nvar compression = require('compression')\r\nvar express = require('express')\r\n\r\nvar app = express()\r\n\r\napp.use(compression({ filter: shouldCompress }))\r\n\r\nfunction shouldCompress (req, res) {\r\n  if (req.headers['x-no-compression']) {\r\n    // don't compress responses with this request header\r\n    return false\r\n  }\r\n\r\n  // fallback to standard filter function\r\n  return compression.filter(req, res)\r\n}\r\nres.flush\r\nThis module adds a res.flush() method to force the partially-compressed response to be flushed to the client.\r\n\r\nExamples\r\nexpress\r\nWhen using this module with express, simply app.use the module as high as you like. Requests that pass through the middleware will be compressed.\r\n\r\nvar compression = require('compression')\r\nvar express = require('express')\r\n\r\nvar app = express()\r\n\r\n// compress all responses\r\napp.use(compression())\r\n\r\n// add all routes\r\nNode.js HTTP server\r\nvar compression = require('compression')({ threshold: 0 })\r\nvar http = require('http')\r\n\r\nfunction createServer (fn) {\r\n  return http.createServer(function (req, res) {\r\n    compression(req, res, function (err) {\r\n      if (err) {\r\n        res.statusCode = err.status || 500\r\n        res.end(err.message)\r\n        return\r\n      }\r\n\r\n      fn(req, res)\r\n    })\r\n  })\r\n}\r\n\r\nvar server = createServer(function (req, res) {\r\n  res.setHeader('Content-Type', 'text/plain')\r\n  res.end('hello world!')\r\n})\r\n\r\nserver.listen(3000, () => {\r\n  console.log('> Listening at http://localhost:3000')\r\n})\r\nServer-Sent Events\r\nBecause of the nature of compression this module does not work out of the box with server-sent events. To compress content, a window of the output needs to be buffered up in order to get good compression. Typically when using server-sent events, there are certain block of data that need to reach the client.\r\n\r\nYou can achieve this by calling res.flush() when you need the data written to actually make it to the client.\r\n\r\nvar compression = require('compression')\r\nvar express = require('express')\r\n\r\nvar app = express()\r\n\r\n// compress responses\r\napp.use(compression())\r\n\r\n// server-sent event stream\r\napp.get('/events', function (req, res) {\r\n  res.setHeader('Content-Type', 'text/event-stream')\r\n  res.setHeader('Cache-Control', 'no-cache')\r\n\r\n  // send a ping approx every 2 seconds\r\n  var timer = setInterval(function () {\r\n    res.write('data: ping\\n\\n')\r\n\r\n    // !!! this is the important part\r\n    res.flush()\r\n  }, 2000)\r\n\r\n  res.on('close', function () {\r\n    clearInterval(timer)\r\n  })\r\n})\r\nContributing\r\nThe Express.js project welcomes all constructive contributions. Contributions take many forms, from code for bug fixes and enhancements, to additions and fixes to documentation, additional tests, triaging incoming pull requests and issues, and more!\r\n\r\nSee the Contributing Guide for more technical details on contributing.\r\n\r\nLicense\r\nMIT"}